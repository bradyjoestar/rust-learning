pub mod thread_simple_demo;

pub mod channel;

/*
将程序中的计算拆分进多个线程可以改善性能，因为程序可以同时进行多个任务，不过这也会增加复杂性。
因为线程是同时运行的，所以无法预先保证不同线程中的代码的执行顺序。这会导致诸如此类的问题：

竞争状态（Race conditions），多个线程以不一致的顺序访问数据或资源
死锁（Deadlocks），两个线程相互等待对方停止使用其所拥有的资源，这会阻止它们继续运行
只会发生在特定情况且难以稳定重现和修复的 bug.

起初，Rust 团队认为确保内存安全和防止并发问题是两个分别需要不同方法应对的挑战。
随着时间的推移，团队发现所有权和类型系统是一系列解决内存安全 和 并发问题的强有力的工具！
通过改进所有权和类型检查，Rust 很多并发错误都是 编译时 错误，而非运行时错误。
因此，相比花费大量时间尝试重现运行时并发 bug 出现的特定情况，
Rust 会拒绝编译不正确的代码并提供解释问题的错误信息。
因此，你可以在开发时而不是不慎部署到生产环境后修复代码。


线程安全虽然处处接触到内存，但跟内存安全还不是一回事.
内存安全可以被定义为：不访问任何未定义的内存。如：避免缓冲区溢出，避免引用未初始化等。
线程安全被定义为：多个线程访问类时，无论采取何种调度方式，主调代码中也不需要额外的同步和协同，都能表现出正确的行为。
同样是对内存进行操作，线程安全考虑的是其中包含数据的安全性，而非内存地址本身的问题。

memory safety: https://en.wikipedia.org/wiki/Memory_safety
*/
